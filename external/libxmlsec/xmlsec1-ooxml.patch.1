From 1770428d30a77e7c5e3344687369d83e04201f0b Mon Sep 17 00:00:00 2001
From: Miklos Vajna <vmiklos@collabora.co.uk>
Date: Mon, 25 Jan 2016 09:50:03 +0100
Subject: [PATCH] OOXML Relationship Transform skeleton

---
 include/xmlsec/strings.h    |   3 +
 include/xmlsec/transforms.h |   4 +
 src/strings.c               |   3 +
 src/transforms.c            |  11 ++
 src/xpath.c                 | 279 ++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 300 insertions(+)

diff --git a/include/xmlsec/strings.h b/include/xmlsec/strings.h
index 07afb9d..9c72d1b 100644
--- a/include/xmlsec/strings.h
+++ b/include/xmlsec/strings.h
@@ -551,6 +551,9 @@ XMLSEC_EXPORT_VAR const xmlChar xmlSecXPath2FilterUnion[];
 XMLSEC_EXPORT_VAR const xmlChar xmlSecNameXPointer[];
 XMLSEC_EXPORT_VAR const xmlChar xmlSecNodeXPointer[];
 
+XMLSEC_EXPORT_VAR const xmlChar xmlSecNameRelationship[];
+XMLSEC_EXPORT_VAR const xmlChar xmlSecHrefRelationship[];
+
 /*************************************************************************
  *
  * Xslt strings
diff --git a/include/xmlsec/transforms.h b/include/xmlsec/transforms.h
index 4008cae..b0e31e4 100644
--- a/include/xmlsec/transforms.h
+++ b/include/xmlsec/transforms.h
@@ -961,6 +961,10 @@ XMLSEC_EXPORT int		xmlSecTransformXPointerSetExpr		(xmlSecTransformPtr transform
 									 const xmlChar* expr,
 									 xmlSecNodeSetType nodeSetType,
 									 xmlNodePtr hereNode);
+
+#define xmlSecTransformRelationshipId xmlSecTransformRelationshipGetKlass()
+XMLSEC_EXPORT xmlSecTransformId xmlSecTransformRelationshipGetKlass (void);
+
 #ifndef XMLSEC_NO_XSLT
 /**
  * xmlSecTransformXsltId:
diff --git a/src/strings.c b/src/strings.c
index 9897198..546e993 100644
--- a/src/strings.c
+++ b/src/strings.c
@@ -543,6 +543,9 @@ const xmlChar xmlSecXPath2FilterUnion[]		= "union";
 const xmlChar xmlSecNameXPointer[]		= "xpointer";
 const xmlChar xmlSecNodeXPointer[]		= "XPointer";
 
+const xmlChar xmlSecNameRelationship[] = "relationship";
+const xmlChar xmlSecHrefRelationship[] = "http://schemas.openxmlformats.org/package/2006/RelationshipTransform";
+
 /*************************************************************************
  *
  * Xslt strings
diff --git a/src/transforms.c b/src/transforms.c
index 2ed3fe8..9e5ad27 100644
--- a/src/transforms.c
+++ b/src/transforms.c
@@ -271,6 +271,17 @@ xmlSecTransformIdsRegisterDefault(void) {
 	return(-1);
     }
 
+    if (xmlSecTransformIdsRegister(xmlSecTransformRelationshipId) < 0)
+    {
+	xmlSecError(XMLSEC_ERRORS_HERE,
+		    NULL,
+		    "xmlSecTransformIdsRegister",
+		    XMLSEC_ERRORS_R_XMLSEC_FAILED,
+		    "name=%s",
+		    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformRelationshipId)));
+	return -1;
+    }
+
 #ifndef XMLSEC_NO_XSLT
     if(xmlSecTransformIdsRegister(xmlSecTransformXsltId) < 0) {
 	xmlSecError(XMLSEC_ERRORS_HERE,
diff --git a/src/xpath.c b/src/xpath.c
index 8b0b4f8..ddcd95d 100644
--- a/src/xpath.c
+++ b/src/xpath.c
@@ -17,6 +17,7 @@
 #include <libxml/xpath.h>
 #include <libxml/xpathInternals.h>
 #include <libxml/xpointer.h>
+#include <libxml/c14n.h>
 
 #include <xmlsec/xmlsec.h>
 #include <xmlsec/xmltree.h>
@@ -1144,5 +1145,283 @@ xmlSecTransformVisa3DHackExecute(xmlSecTransformPtr transform, int last,
     return(0);
 }
 
+/* OOXML Relationship Transform. */
+typedef struct _xmlSecRelationshipCtx xmlSecRelationshipCtx, *xmlSecRelationshipCtxPtr;
+struct _xmlSecRelationshipCtx
+{
+    xmlParserCtxtPtr parserCtx;
+};
+#define xmlSecRelationshipSize (sizeof(xmlSecTransform) + sizeof(xmlSecRelationshipCtx))
+#define xmlSecRelationshipGetCtx(transform) ((xmlSecRelationshipCtxPtr)(((xmlSecByte*)(transform)) + sizeof(xmlSecTransform)))
+
+static int xmlSecRelationshipInitialize (xmlSecTransformPtr transform);
+static void xmlSecRelationshipFinalize (xmlSecTransformPtr transform);
+static int xmlSecTransformRelationshipPopBin(xmlSecTransformPtr transform, xmlSecByte* data, xmlSecSize maxDataSize, xmlSecSize* dataSize, xmlSecTransformCtxPtr transformCtx);
+static int xmlSecTransformRelationshipPushXml(xmlSecTransformPtr transform, xmlSecNodeSetPtr nodes, xmlSecTransformCtxPtr transformCtx);
+
+static xmlSecTransformKlass xmlSecRelationshipKlass =
+{
+    /* klass/object sizes */
+    sizeof(xmlSecTransformKlass), /* xmlSecSize klassSize */
+    xmlSecRelationshipSize, /* xmlSecSize objSize */
+    xmlSecNameRelationship, /* const xmlChar* name; */
+    xmlSecHrefRelationship, /* const xmlChar* href; */
+    xmlSecTransformUsageDSigTransform, /* xmlSecAlgorithmUsage usage; */
+    xmlSecRelationshipInitialize, /* xmlSecTransformInitializeMethod initialize; */
+    xmlSecRelationshipFinalize, /* xmlSecTransformFinalizeMethod finalize; */
+    NULL, /* xmlSecTransformNodeReadMethod readNode; */
+    NULL, /* xmlSecTransformNodeWriteMethod writeNode; */
+    NULL, /* xmlSecTransformSetKeyReqMethod setKeyReq; */
+    NULL, /* xmlSecTransformSetKeyMethod setKey; */
+    NULL, /* xmlSecTransformValidateMethod validate; */
+    xmlSecTransformDefaultGetDataType, /* xmlSecTransformGetDataTypeMethod getDataType; */
+    NULL, /* xmlSecTransformPushBinMethod pushBin; */
+    xmlSecTransformRelationshipPopBin, /* xmlSecTransformPopBinMethod popBin; */
+    xmlSecTransformRelationshipPushXml, /* xmlSecTransformPushXmlMethod pushXml; */
+    NULL, /* xmlSecTransformPopXmlMethod popXml; */
+    NULL, /* xmlSecTransformExecuteMethod execute; */
+    NULL, /* void* reserved0; */
+    NULL, /* void* reserved1; */
+};
+
+xmlSecTransformId xmlSecTransformRelationshipGetKlass(void)
+{
+    return &xmlSecRelationshipKlass;
+}
+
+static int xmlSecRelationshipInitialize(xmlSecTransformPtr transform)
+{
+    xmlSecRelationshipCtxPtr ctx;
+
+    xmlSecAssert2(xmlSecTransformCheckId(transform, xmlSecTransformRelationshipId), -1);
+    xmlSecAssert2(xmlSecTransformCheckSize(transform, xmlSecRelationshipSize), -1);
+
+    ctx = xmlSecRelationshipGetCtx(transform);
+    xmlSecAssert2(ctx != NULL, -1);
+
+    /* initialize context */
+    memset(ctx, 0, sizeof(xmlSecRelationshipCtx));
+    return 0;
+}
+
+static void xmlSecRelationshipFinalize(xmlSecTransformPtr transform)
+{
+    xmlSecRelationshipCtxPtr ctx;
+
+    xmlSecAssert(xmlSecTransformCheckId(transform, xmlSecTransformRelationshipId));
+    xmlSecAssert(xmlSecTransformCheckSize(transform, xmlSecRelationshipSize));
+
+    ctx = xmlSecRelationshipGetCtx(transform);
+    xmlSecAssert(ctx != NULL);
+
+    if (ctx->parserCtx != NULL)
+	xmlFreeParserCtxt(ctx->parserCtx);
+
+    memset(ctx, 0, sizeof(xmlSecRelationshipCtx));
+}
+
+static int xmlSecTransformRelationshipPushXml(xmlSecTransformPtr transform, xmlSecNodeSetPtr nodes, xmlSecTransformCtxPtr transformCtx)
+{
+    xmlOutputBufferPtr buf;
+    int ret;
+
+    xmlSecAssert2(nodes != NULL, -1);
+    xmlSecAssert2(nodes->doc != NULL, -1);
+    xmlSecAssert2(transformCtx != NULL, -1);
+
+    /* check/update current transform status */
+    switch(transform->status)
+    {
+    case xmlSecTransformStatusNone:
+	transform->status = xmlSecTransformStatusWorking;
+	break;
+    case xmlSecTransformStatusWorking:
+    case xmlSecTransformStatusFinished:
+	return(0);
+    default:
+	xmlSecError(XMLSEC_ERRORS_HERE,
+		    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+		    NULL,
+		    XMLSEC_ERRORS_R_INVALID_STATUS,
+		    "status=%d", transform->status);
+	return(-1);
+    }
+    xmlSecAssert2(transform->status == xmlSecTransformStatusWorking, -1);
+
+    /* prepare output buffer: next transform or ourselves */
+    if(transform->next != NULL)
+    {
+	buf = xmlSecTransformCreateOutputBuffer(transform->next, transformCtx);
+	if(buf == NULL)
+	{
+	    xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlSecTransformCreateOutputBuffer",
+			XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    return(-1);
+	}
+    } else
+    {
+	buf = xmlSecBufferCreateOutputBuffer(&(transform->outBuf));
+	if (buf == NULL)
+	{
+	    xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlSecBufferCreateOutputBuffer",
+			XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    return(-1);
+	}
+    }
 
+    ret = xmlC14NExecute(nodes->doc, (xmlC14NIsVisibleCallback)xmlSecNodeSetContains, nodes, XML_C14N_1_0, NULL, 0, buf);
+    if (ret < 0)
+    {
+	xmlSecError(XMLSEC_ERRORS_HERE,
+		    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+		    "xmlC14NExecute",
+		    XMLSEC_ERRORS_R_XMLSEC_FAILED,
+		    XMLSEC_ERRORS_NO_MESSAGE);
+	xmlOutputBufferClose(buf);
+	return(-1);
+    }
 
+    ret = xmlOutputBufferClose(buf);
+    if (ret < 0)
+    {
+	xmlSecError(XMLSEC_ERRORS_HERE,
+		    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+		    "xmlOutputBufferClose",
+		    XMLSEC_ERRORS_R_XML_FAILED,
+		    XMLSEC_ERRORS_NO_MESSAGE);
+	return(-1);
+    }
+    transform->status = xmlSecTransformStatusFinished;
+    return(0);
+}
+
+static int xmlSecTransformRelationshipPopBin(xmlSecTransformPtr transform, xmlSecByte* data, xmlSecSize maxDataSize, xmlSecSize* dataSize, xmlSecTransformCtxPtr transformCtx)
+{
+    xmlSecBufferPtr out;
+    int ret;
+
+    xmlSecAssert2(data != NULL, -1);
+    xmlSecAssert2(dataSize != NULL, -1);
+    xmlSecAssert2(transformCtx != NULL, -1);
+
+    out = &(transform->outBuf);
+    if (transform->status == xmlSecTransformStatusNone)
+    {
+	xmlOutputBufferPtr buf;
+
+	xmlSecAssert2(transform->inNodes == NULL, -1);
+
+	/* todo: isn't it an error? */
+	if (transform->prev == NULL)
+	{
+	    (*dataSize) = 0;
+	    transform->status = xmlSecTransformStatusFinished;
+	    return(0);
+	}
+
+	/* get xml data from previous transform */
+	ret = xmlSecTransformPopXml(transform->prev, &(transform->inNodes), transformCtx);
+	if (ret < 0)
+	{
+	    xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlSecTransformPopXml",
+			XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    return(-1);
+	}
+
+	/* dump everything to internal buffer */
+	buf = xmlSecBufferCreateOutputBuffer(out);
+	if (buf == NULL)
+	{
+	    xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlSecBufferCreateOutputBuffer",
+			XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    return(-1);
+	}
+
+        ret = xmlC14NExecute(transform->inNodes->doc, (xmlC14NIsVisibleCallback)xmlSecNodeSetContains, transform->inNodes, XML_C14N_1_0, NULL, 0, buf);
+        if (ret < 0)
+	{
+            xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlSecTransformC14NExecute",
+			XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    xmlOutputBufferClose(buf);
+	    return(-1);
+	}
+	ret = xmlOutputBufferClose(buf);
+	if (ret < 0)
+	{
+	    xmlSecError(XMLSEC_ERRORS_HERE,
+			xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			"xmlOutputBufferClose",
+			XMLSEC_ERRORS_R_XML_FAILED,
+			XMLSEC_ERRORS_NO_MESSAGE);
+	    return(-1);
+	}
+	transform->status = xmlSecTransformStatusWorking;
+    }
+
+    if (transform->status == xmlSecTransformStatusWorking)
+    {
+	xmlSecSize outSize;
+
+	/* return chunk after chunk */
+	outSize = xmlSecBufferGetSize(out);
+	if (outSize > maxDataSize)
+	{
+	    outSize = maxDataSize;
+	}
+	if (outSize > XMLSEC_TRANSFORM_BINARY_CHUNK)
+	{
+	    outSize = XMLSEC_TRANSFORM_BINARY_CHUNK;
+	}
+	if (outSize > 0)
+	{
+	    xmlSecAssert2(xmlSecBufferGetData(&(transform->outBuf)), -1);
+
+	    memcpy(data, xmlSecBufferGetData(&(transform->outBuf)), outSize);
+	    ret = xmlSecBufferRemoveHead(&(transform->outBuf), outSize);
+            if (ret < 0)
+	    {
+		xmlSecError(XMLSEC_ERRORS_HERE,
+			    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+			    "xmlSecBufferRemoveHead",
+			    XMLSEC_ERRORS_R_XMLSEC_FAILED,
+			    "size=%d", outSize);
+		return(-1);
+	    }
+	}
+	else if (xmlSecBufferGetSize(out) == 0)
+	    transform->status = xmlSecTransformStatusFinished;
+	(*dataSize) = outSize;
+    }
+    else if (transform->status == xmlSecTransformStatusFinished)
+    {
+	/* the only way we can get here is if there is no output */
+	xmlSecAssert2(xmlSecBufferGetSize(out) == 0, -1);
+	(*dataSize) = 0;
+    }
+    else
+    {
+	xmlSecError(XMLSEC_ERRORS_HERE,
+		    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
+		    NULL,
+		    XMLSEC_ERRORS_R_INVALID_STATUS,
+		    "status=%d", transform->status);
+	return(-1);
+    }
+
+    return(0);
+}
-- 
2.6.2

