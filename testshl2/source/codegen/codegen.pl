#!/usr/bin/perl

# @lines
# push(@lines, $line)    append
# pop(@lines)            remove last
# shift(@lines)          remove at first
# unshift(@lines, $line) insert at first
# $lines[-1]             get last
# foreach $line (@lines)

# $a eq $b compares strings
# $a == $b compares digits

# split operator
# ($vorname, $nachname, $email) = split (/\s+/, $person);

my $sCurrentPackage = "";
my $sCurrentClass = "";
my @sMethodNames;
my @sClassNameStack;
my @sFilenameStack;
my $sCurrentFilename;
my $bShowDemo = 1;

# ------------------------------------------------------------------------------
sub createFilename
{
    my $sPackageName = shift;
    my $sFilename = "$sPackageName.cxx";
    while ( -e $sFilename)
    {
        $nCount ++;
        $sFilename = "$sPackageName" . "_$nCount";
    }
    push(@sFilenameStack, $sFilename);

    $sCurrentFilename = $sFilename . ".cxx";
    return $sFilename;
}
# ------------------------------------------------------------------------------

sub generateNewPackage
{
    my $sPackageName = shift;

    my $sFilename = createFilename($sPackageName);
    open(CPPFILE, ">$sFilename") || die "can't create cxx source file";
    print CPPFILE "// autogenerated file with codegen.pl\n";
    print CPPFILE "\n";
    print CPPFILE "#include <cppunit/simpleheader.hxx>\n";
    print CPPFILE "\n";
    print CPPFILE "namespace $sPackageName\n";
    print CPPFILE "{\n";

}

# ------------------------------------------------------------------------------
sub generateNewClass
{
    my $sClassName = shift;
    print CPPFILE "\n";
    print CPPFILE "class $sClassName : public CppUnit::TestFixture\n";
    print CPPFILE "{\n";
}
# ------------------------------------------------------------------------------
sub closeMethods
{
    # due to the fact, that this is a function based code, not object based
    # we have to do some hacks, to prevent us from creating wrong code
    if ($sCurrentClass =~ /^$/ || $sCurrentPackage =~ /^$/ )
    {
        return;
    }

    # here we create the methods
    # first the setUp() and tearDown()
    print CPPFILE "    // initialise your test code values here.\n";
    print CPPFILE "    void setUp()\n";
    print CPPFILE "    {\n";
    print CPPFILE "    }\n";
    print CPPFILE "\n";
    print CPPFILE "    void tearDown()\n";
    print CPPFILE "    {\n";
    print CPPFILE "    }\n";
    print CPPFILE "\n";

    print CPPFILE "    // insert your test code here.\n";
    if ($#sMethodNames > 0)
    {
        # all found methods
        foreach $sMethod (@sMethodNames)
        {
            print CPPFILE "    void $sMethod()\n";
            print CPPFILE "    {\n";
            if ($bShowDemo == 1)
            {
                print CPPFILE "        // this is demonstration code\n";
                print CPPFILE "        // CPPUNIT_ASSERT_MESSAGE(\"a message\", 1 == 1);\n";
                $bShowDemo = 0;
            }
            print CPPFILE "        CPPUNIT_ASSERT_STUB();\n";
            print CPPFILE "    }\n";
            print CPPFILE "\n";
        }
    }
    else
    {
        # if no methods found, create at least one
        print CPPFILE "    // this is only demonstration code\n";
        print CPPFILE "    void EmptyMethod()\n";
        print CPPFILE "    {\n";
        print CPPFILE "       // CPPUNIT_ASSERT_MESSAGE(\"a message\", 1 == 1);\n";
        print CPPFILE "       CPPUNIT_ASSERT_STUB();\n";
        print CPPFILE "    }\n";
        print CPPFILE "\n";
    }

    # create the autoregister code
    print CPPFILE "    // Change the following lines only, if you add, remove or rename \n";
    print CPPFILE "    // member functions of the current class, \n";
    print CPPFILE "    // because these macros are need by auto register mechanism.\n";
    print CPPFILE "\n";

    print CPPFILE "    CPPUNIT_TEST_SUITE($sCurrentClass);\n";
    push(@sClassNameStack, $sCurrentClass);

    my $nCount = 0;
    if ($#sMethodNames > 0)
    {
        foreach $sMethod (@sMethodNames)
        {
            print CPPFILE "    CPPUNIT_TEST($sMethod);\n";
            $nCount ++;
        }
        # empty the method list
        my $i;
        for ($i = 0;$i < $nCount;$i++)
        {
            pop(@sMethodNames);
        }
    }
    else
    {
        print CPPFILE "    CPPUNIT_TEST(EmptyMethod);\n";
    }
    print CPPFILE "    CPPUNIT_TEST_SUITE_END();\n";
}

# ------------------------------------------------------------------------------
sub closeClass
{
    # my $sClassName = shift;
    if ($sCurrentClass =~ /^$/)
    {
        return;
    }
    print CPPFILE "}; // class $sCurrentClass\n";
    print CPPFILE "\n";
    $sCurrentClass = "";
}
# ------------------------------------------------------------------------------

sub closePackage
{
    # my $sPackageName = shift;
    if ($sCurrentPackage =~ /^$/)
    {
        return;
    }
    # create the autoregister code
    print CPPFILE "// -----------------------------------------------------------------------------\n";
    my $nCount = 0;
    foreach $sClassName (@sClassNameStack)
    {
        print CPPFILE "CPPUNIT_TEST_SUITE_NAMED_REGISTRATION($sCurrentPackage" . "::" . "$sClassName, \"$sCurrentPackage\");\n";
        $nCount ++;
    }
    # empty the method list
    my $i;
    for ($i = 0;$i < $nCount;$i++)
    {
        pop(@sClassNameStack);
    }

    print CPPFILE "} // namespace $sCurrentPackage\n";
    print CPPFILE "\n";
    print CPPFILE "
// -----------------------------------------------------------------------------

// this macro creates an empty function, which will called by the RegisterAllFunctions()
// to let the user the possibility to also register some functions by hand.
NOADDITIONAL;
";
    print CPPFILE "\n";

    close(CPPFILE);

    push(@sPackageStack, $sCurrentPackage);

    $sCurrentPackage = "";
}

# ------------------------------------------------------------------------------

# sub generateCppSource
# {
#     my $sPackageName = shift;
#     my $sClassName = shift;
#     my $sMethodName = shift;
#
#
#     open(CPPFILE, ">$sFilename") || die "can't create cxx source file";
#     print CPPFILE "// autogenerated file\n";
#     close(CPPFILE);
# }
# ------------------------------------------------------------------------------
sub walkThroughJobFile
{
    my $filename = shift;

    open(FILE, $filename) || die "can't open $filename\n";

    while($line = <FILE>)
    {
        chomp($line);
        # DOS Hack grrrr...
        while ($line =~ /$/)
        {
            $line = substr($line, 0, -1);
        }

        if ($line =~ /^\#/ || $line =~ /^$/)
        {
            # remark or empty line
        }
        else
        {
            if ($line =~ /^\w+/) # must start with a word character
            {
                # print "$line\n";
                my ($sPackageName, $sClassName, $sMethodName);
                ($sPackageName, $sClassName, $sMethodName) = split(/\./, $line);
                if ($sClassName =~ /^$/)
                {
                    print "error: in $line, no class name exist.\n";
                }
                # test if it also works without methods
                # elsif ($sMethodName =~ /^$/)
                # {
                #     print "error: in $line, no method name exist.\n";
                # }
                else
                {
                    if ($sMethodName =~ /^$/)
                    {
                        print "warning: in $line, no method name exist, create only on pseudo member function.\n";
                    }

                    print "$sPackageName :: $sClassName :: $sMethodName\n";

                    if ($sCurrentPackage ne $sPackageName)
                    {
                        closeMethods();
                        closeClass();
                        closePackage();

                        $sCurrentPackage = $sPackageName;
                        generateNewPackage($sPackageName);
                    }
                    if ($sCurrentClass ne $sClassName)
                    {
                        closeMethods();
                        closeClass();
                        $sCurrentClass = $sClassName;
                        generateNewClass($sClassName);
                    }
                    push(@sMethodNames, $sMethodName);
                }
            }
        }
    }

    closeMethods();
    closeClass();
    closePackage();
    close(FILE);

    # generate makefile
    generateMakefileEntry("test");
}

# ------------------------------------------------------------------------------
sub generateMakefileEntry
{
    my $sTargetName = shift;
    my $nNumber;
    $nNumber = 1;

    open(MAKEFILE, ">makefile.add") || die "can't open makefile.add";

    print MAKEFILE "SHL" . $nNumber . "OBJS= ";
    foreach $sFilename (@sFilenameStack)
    {
        print MAKEFILE " \\\n";
        print MAKEFILE "    \$(SLO)\$/$sFilename.obj";
    }
    print MAKEFILE "\n\n";

    # targetname
    print MAKEFILE "SHL" . $nNumber . "TARGET= $sTargetName\n";
    # additional libraries
    print MAKEFILE "SHL" . $nNumber . "STDLIBS=\\\n";
    print MAKEFILE "   \$(SALLIB) \n";
    # link static cppunit library
    print MAKEFILE ".IF \"\$(GUI)\" == \"WNT\"\n";
    print MAKEFILE "SHL" . $nNumber . "STDLIBS+=    \$(SOLARLIBDIR)\$/cppunit.lib\n";
    print MAKEFILE ".ENDIF\n";
    print MAKEFILE ".IF \"\$(GUI)\" == \"UNX\"\n";
    print MAKEFILE "SHL" . $nNumber . "STDLIBS+=\$(SOLARLIBDIR)\$/libcppunit\$(DLLPOSTFIX).a\n";
    print MAKEFILE ".ENDIF\n";
    print MAKEFILE "\n";
    print MAKEFILE "SHL" . $nNumber . "IMPLIB= i\$(SHL" . $nNumber . "TARGET)\n";
    print MAKEFILE "SHL" . $nNumber . "DEF=    \$(MISC)\$/\$(SHL" . $nNumber . "TARGET).def\n";
    print MAKEFILE "\n";
    # DEF name
    print MAKEFILE "DEF" . $nNumber . "NAME    =\$(SHL" . $nNumber . "TARGET)\n";
    print MAKEFILE "DEF" . $nNumber . "EXPORTFILE= export.exp\n";

    close(MAKEFILE);

    if (! -e "export.exp")
    {
        open(EXPORTEXP, ">export.exp") || die "can't create export.exp";
        print EXPORTEXP "registerAllTestFunction\n";
        close(EXPORTEXP);
    }
}
# -------------------------------- main function --------------------------------

sub main
{
    if ($#ARGV < 0)
    {
        usage();
    }
    my $jobfile = $ARGV[0];

    print "Test code generator\n";

    walkThroughJobFile($jobfile);
}

# ------------------------------------------------------------------------------

main();
