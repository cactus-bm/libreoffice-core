:
eval 'exec perl -wS $0 ${1+"$@"}'
    if 0;
#*************************************************************************
#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
# 
# Copyright 2008 by Sun Microsystems, Inc.
#
# OpenOffice.org - a multi-platform office productivity suite
#
# $RCSfile: cws-commit-patch,v $
#
# $Revision: 1.3 $
#
# This file is part of OpenOffice.org.
#
# OpenOffice.org is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# only, as published by the Free Software Foundation.
#
# OpenOffice.org is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License version 3 for more details
# (a copy is included in the LICENSE file that accompanied this code).
#
# You should have received a copy of the GNU Lesser General Public License
# version 3 along with OpenOffice.org.  If not, see
# <http://www.openoffice.org/license.html>
# for a copy of the LGPLv3 License.
#
#*************************************************************************

use Cwd 'abs_path';

$default_mws = 'SRC680';

sub usage()
{
    print STDERR <<EOS;
cws-commit-patch - automate the creation of CWSes
Usage: cws-commit-patch ...params... patch1.diff patch2.diff ...

  -i, --iz        IZ number (XXXX or iXXXX)
  -c, --cws       CWS name (to be created or existing)
  -d, --default   Default to the latest milestone in MWS $default_mws
  -h, --help      Help
  -m, --milestone Milestone to base the CWS on (when -d is not used)
  -r, --root      cvs root
  -s, --summary   Summary describing the change (for cvs commit)
  -w, --mws       MWS (Master Workspace) (when -d is not used)
  
Eg. cws-commit-patch -i 1234 -c fix01 -d -r :pserver:me\@localhost:/cvs \\
                     -s \"Fixes this and that\" fix01-patch.diff
EOS
    exit 1;
}

sub cws_create($$$)
{
    my ( $mws, $cws, $milestone ) = @_;
    system( "echo '===== cws_create =====' >> .log" );

    my $tmp = `mktemp -d /tmp/cws-$cws.XXXXXX`;
    chomp( $tmp );
    print "Temp dir:\t$tmp\n";

    chdir( $tmp );
    $ENV{SRC_ROOT} = $tmp;

    my $state = `cwsquery -m $mws -c $cws state 2>> .log`;
    $state =~ s/\n//g;
    if ( $state ne "" && $state ne "planned" ) {
        print "CWS:\t\t'$cws' already exists, its state is '$state'\n";
    }
    else {
        print "CWS:\t\tcreating '$cws'\n";

        if ( system( "cwscreate -f $mws $milestone $cws 2>> .log" ) != 0 ) {
            print STDERR "Unable to execute cwscreate.\n";
            exit 1;
        }
        print "CWS:\t\t'$cws' created\n";
    }
}

sub cws_modules($$)
{
    my ( $mws, $cws ) = @_;

    my $mod_str = `cwsquery -m $mws -c $cws modules 2>> .log`;
    return split( '\n', $mod_str );
}

sub cws_add_modules($$$@)
{
    my ( $mws, $cws, $milestone, @patches ) = @_;
    system( "echo '===== cws_add_modules =====' >> .log" );

    my %modules = ();

    for $patch ( @patches ) {
        if ( ! open( $PATCH, "$patch" ) ) {
            print STDERR "Unable to open patch '$patch'.";
            exit 1;
        }
        while (<$PATCH>) {
            if ( /^\+\+\+ ([^\/]*)/ ) {
                if ( $1 ne "" ) {
                    $modules{$1} = "add";
                }
                else {
                    print STDERR "Unable to guess module name ($1) from $patch.\n";
                    close( $PATCH );
                    exit 1;
                }
            }
        }
        close( $PATCH );
    }

    my @cws_modules = cws_modules( $mws, $cws );
    for $cws_mod ( @cws_modules ) {
        if ( defined( $modules{$cws_mod} ) ) {
            $modules{$cws_mod} = "checkout";
        }
    }

    while ( ( $module, $what ) = each( %modules ) ) {
        if ( $what eq "add" ) {
            print "Tagging:\tModule '$module'... Be patient, please ;)\n";
            if ( system( "cvs checkout -r " . uc($mws) . "_$milestone $module >> .log 2>&1" ) != 0 ) {
                print STDERR "Unable to execute cvs checkout.\n";
                exit 1;
            }
            if ( system( "cwsadd -a -f $module >> .log 2>&1" ) != 0 ) {
                print STDERR "Unable to execute cwsadd.\n";
                exit 1;
            }
            print "Module:\t\t'$module' added to $cws\n";
        }
        elsif ( $what eq "checkout" ) {
            print "Checking out:\tModule '$module'\n";
            if ( system( "cvs checkout -r cws_" . lc($mws) . "_$cws $module >> .log 2>&1" ) != 0 ) {
                print STDERR "Unable to execute cvs checkout.\n";
                exit 1;
            }
            print "Module:\t\t'$module' already exists in $cws, checked out\n";
        }
    }
}

sub cws_add_task($)
{
    my ( $iz ) = @_;
    system( "echo '===== cws_add_task =====' >> .log" );

    if ( system( "cwsaddtask i$iz 2>> .log" ) != 0 ) {
        print STDERR "Unable to add task number $iz.\n";
        exit 1;
    }

    print "IZ:\t\tSet to '$iz'\n";
}

sub apply_patches(@)
{
    my ( @patches ) = @_;
    system( "echo '===== apply_patches =====' >> .log" );

    for $patch ( @patches ) {
        print "Patch:\t\tApplying '$patch'\n";
        if ( system( "unset POSIXLY_CORRECT ; patch -p0 -i $patch" ) != 0 ) {
            print STDERR "Unable to apply patch $patch.\n";
            exit 1;
        }
        print "Patch:\t\t'$patch' OK\n";
    }
}

sub cvs_add_files(@)
{
    my ( @patches ) = @_;
    system( "echo '===== cvs_add_files =====' >> .log" );

    my %modules = ();

    for my $patch ( @patches ) {
        if ( ! open( $PATCH, "$patch" ) ) {
            print STDERR "Unable to open patch '$patch'.";
            exit 1;
        }
	my $file_add = "";
        while (<$PATCH>) {
            if ( /^\+\+\+ ([^\s]*)/ ) {
                if ( $1 ne "" ) {
		    $file_add = $1;
                }
            }
            elsif ( /^\@\@ -0,0 / && $file_add ne "" ) {
		my @to_add = split( /\//, $file_add );
		my $current = "";
		for my $add ( @to_add ) {
		    $current .= "/" unless ( $current eq "" );
		    my $where_add_dir = $current;
		    $current .= $add;

		    if ( ( -d "$current" && ! -d "$current/CVS" ) || ( -f "$current" ) ) {
			if ( system( "cd $where_add_dir && cvs add $add" ) != 0 ) {
			    print STDERR "Unable to exec 'cd $where_add_dir && cvs add $add'.\n";
			    close( $PATCH );
			    exit 1;
			}
		    }
		}
	    }
        }
        close( $PATCH );
    }
}

sub cws_commit($$$$$@)
{
    my ( $mws, $cws, $iz, $summary, $milestone, @patches ) = @_;

    cws_create( $mws, $cws, $milestone );
    cws_add_modules( $mws, $cws, $milestone, @patches );
    cws_add_task( $iz );

    apply_patches( @patches );

    cvs_add_files( @patches );

    my @cws_modules = cws_modules( $mws, $cws );
    my $commit_message = "#i$iz#\n" . $summary;
    $commit_message =~ s/'/'\\''/g;

    my $commit = "cvs commit -m '$commit_message' ";
    for $module ( @cws_modules ) {
        if ( -d $module ) {
            $commit .= $module . " ";
        }
    }
    print "CVS:\t\t$commit\n";
    if ( system( $commit ) != 0 ) {
        print STDERR "cvs commit failed.\n";
        exit 1;
    }
}

#
# main()
#
if ( !defined( $ENV{'SOLARENV'} ) || $ENV{'SOLARENV'} eq '' ) {
    my $build_dir = abs_path( $0 );
    $build_dir =~ s#/solenv/bin/[^/]*$##;
    my $env_script = "";
    if ( -f "$build_dir/LinuxIntelEnv.Set.sh" ) {
	$env_script = "$build_dir/LinuxIntelEnv.Set.sh";
    }
    elsif ( -f "$build_dir/LinuxX86-64Env.Set.sh" ) {
	$env_script = "$build_dir/LinuxX86-64Env.Set.sh";
    }
    else {
        print STDERR "Unable to find '$build_dir/Linux(Intel|X86-64)Env.Set.sh'.\n";
        print STDERR "Please use 'configure' or 'setsolar'.\n";
        exit 1;
    }
    open( $VARS, "bash -c '. $env_script ; set'|");
    while ( <$VARS> ) {
        /([^=]*)=(.*)/ || next;
        $ENV{$1} = $2 unless "$1" eq "SHELLOPTS";
    }
    close( $VARS );
}

my $iz = "";
my $cws = "";
my $mws = "";
my $milestone = "";
my $summary = "";
my @patches = ();
my $use_default = 0;

( my $pwd = `pwd` ) =~ s/\n//;

while (@ARGV) {
    $opt = shift @ARGV;

    if ( $opt eq "-i" || $opt eq "--iz" ) {
        $iz = shift @ARGV;
    }
    elsif ( $opt eq "-c" || $opt eq "--cws" ) {
        $cws = shift @ARGV;
    }
    elsif ( $opt eq "-d" || $opt eq "--default" ) {
        $use_default = 1;
    }
    elsif ( $opt eq "-h" || $opt eq "--help" ) {
        usage();
    }
    elsif ( $opt eq "-r" || $opt eq "--root" ) {
        $ENV{'CVSROOT'} = shift @ARGV;
    }
    elsif ( $opt eq "-s" || $opt eq "--summary" ) {
        $summary = shift @ARGV;
    }
    elsif ( $opt eq "-m" || $opt eq "--milestone" ) {
        $milestone = shift @ARGV;
	if (! ( $milestone =~ m/^m/ ) ) {
	    $milestone = "m$milestone";
	    print "Re-writing milestone to $milestone\n";
	}
    }
    elsif ( $opt eq "-w" || $opt eq "--mws" ) {
        $mws = shift @ARGV;
    }
    else {
        my $patch = $opt;
        if ( $patch =~ /^[^\/]/ ) {
            $patch = "$pwd/$opt";
        }

        if ( -f $patch ) {
            push @patches, $patch;
        }
        else {
            print STDERR "Unable to find patch '$patch'.\n";
            exit 1;
        }
    }
}

if ( !@patches ) {
    print STDERR "No patches to apply.\n";
    exit 1;
}
if ( !defined( $ENV{'CVSROOT'} ) || $ENV{'CVSROOT'} eq "" ) {
    print STDERR "Please specify cvs root (using -r or environment variable).\n";
    exit 1;
}
if ( !defined( $iz ) || !( $iz =~ /^i?[0-9]+$/ ) ) {
    print STDERR "Please specify the IZ number (as XXXX, or iXXXX).\n";
    exit 1;
}
if ( !defined( $cws ) || $cws eq "" ) {
    print STDERR "Please specify the CWS name (where to commit).\n";
    exit 1;
}
if ( !defined( $summary ) || $summary eq "" ) {
    print STDERR "Please provide summary.\n";
    exit 1;
}

if ( !defined( $mws ) || $mws eq "" ) {
    if ( $use_default ) {
        $mws = $default_mws;
        print "MWS:\t\tnot specified, assuming '$mws'\n";
    }
    else {
        print STDERR "Please specify MWS, or use -d.\n";
        exit 1;
    }
}
else {
    print "MWS:\t\t$mws\n";
}

if ( !defined( $milestone ) || $milestone eq "" ) {
    ( $milestone = `cwsquery -m $mws -c $cws current 2> /dev/null` ) =~ s/\n//;
}
if ( $milestone ne "" ) {
    print "Milestone:\t$milestone\n";
}
else {
    if ( $use_default ) {
        my $latest = `cwsquery -m $mws latest 2> /dev/null`;

        ( $_, $milestone ) = split( ' ', $latest );
        print "Milestone:\tnot specified, assuming '$milestone'\n";
    }
    else {
        print STDERR "Please specify milestone, or use -d.\n";
        exit 1;
    }
}

$iz =~ s/^i//;
$ENV{'CWS_WORK_STAMP'} = $cws;
$ENV{'WORK_STAMP'} = $mws;

cws_commit( $mws, $cws, $iz, $summary, $milestone, @patches );

( my $tmp = `pwd` ) =~ s/\n//;
print "
Finished, please check '$tmp' that everything is as expected.
Then:

- Set 'http://www.openoffice.org/issues/show_bug.cgi?id=$iz' to FIXED
  with a 'Committed to CWS $cws.' comment.
- Fill the '$cws' info in 'http://eis.services.openoffice.org'.
\n";
