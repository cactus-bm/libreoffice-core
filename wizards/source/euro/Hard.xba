<?xml version="1.0" encoding="UTF-8"?>

<script:module xmlns:script="http://openoffice.org/2000/script" script:name="Hard" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
&apos;ToDo: WÃ¤hrung wechseln und dann sehen, ob die Listbox mit den neuen Ranges aufgefrischt wird


Sub CreateRangeList()
Dim MaxIndex as Integer
	EnableStep1DialogControls(False, False, False)
	EmptySelection()
	DialogModel.lblSelection.Label = sCURRRANGES  	&apos;&quot;WÃ¤hrungsbereiche:&quot;
	EmptyListbox(DialogModel.lstSelection)
	Msgbox DialogModel.optCellTemplates.State
	oDocument.CurrentController.Select(oSelRanges)
	If (DialogModel.optSheetRanges.State = 1) AND (DialogModel.chkComplete.State &lt;&gt; 1) Then
		&apos; Ist das Sheet Grundlage für die Bearbeitung?
		oStatusline.SetText(sStsRELRANGES)        		&apos;&quot;Erfassung der relevanten Bereiche...&quot;
		osheet = oDocument.CurrentController.GetActiveSheet
		oRanges = osheet.CellFormatRanges.createEnumeration()
		MaxIndex = AddSheetRanges(oRanges, MaxIndex, oSheet, False)
	Else
		CreateRangeEnumeration(False)
		bRangeListDefined = True
	End If
	EnableStep1DialogControls(True, True, True)
	oStatusline.SetText(&quot;&quot;)
End Sub


Sub CreateRangeEnumeration(bAutopilot as Boolean)
Dim i, MaxIndex as integer
Dim sStatustext as String
	MaxIndex = 0
	&apos; oder das Dokument - dann müsssen alle Sheets abgearbeitet werden	
	If Not bRangeListDefined Then
		&apos; Die Ranges sind noch nicht definiert
		oSheets = oDocument.Sheets
		For i = 0 To oSheets.Count-1
			oSheet = oSheets.GetbyIndex(i)
			If bAutopilot Then
				IncreaseStatusValue(SBRELGET/osheets.Count)
			Else
				sStatustext = ReplaceString(sStsRELSHEETRANGES,Str(i+1),&quot;%1Number%1&quot;)
				sStatustext = ReplaceString(sStatusText,oSheets.Count,&quot;%2TotPageCount%2&quot;)
				oStatusline.SetText(sStatusText)
			End If
			oRanges = osheet.CellFormatRanges.createEnumeration
			RangeList(0) = AddSheetRanges(oRanges, MaxIndex, oSheet, bAutopilot)
		Next i
	Else
		oStatusline.SetText(sStsRELRANGES)  	&apos;&quot;Erfassung der relevanten Bereiche...&quot;
		&apos; Die Ranges sind schon definiert
		For I = 0 To CInt(RangeList(0))
			If RangeList(i) &lt;&gt; &quot;&quot; AND RangeBools(i) = True  Then
				If Not bAutoPilot Then
					AddSingleItemToListBox(DialogModel.lstSelection, RangeList(i))
				End If
			End If
		Next
	End If
	Rangeindex = MaxIndex
End Sub
	
	
			
Function AddSheetRanges(oRanges as Object, r as Integer, oSheet as Object, bAutopilot)
Dim RangeName as String
Dim AddtoList as Boolean
Dim iCurStep as Integer
	iCurStep = DialogModel.Step
	While oRanges.hasMoreElements
		oRange = oRanges.NextElement
		AddToList = CheckFormatType(oRange)
		If AddToList Then
			&apos; Den Namen der Range ermitteln und in ein Array packen
			RangeName = RetrieveRangeNamefromAddress(oRange.RangeAddress, oSheet.Name)
			TotCellCount = TotCellCount + CountRangeCells(oRange)
			If Not bAutoPilot Then
				AddSingleItemToListbox(DialogModel.lstSelection, RangeName)
			End If
			&apos; The Ranges are only passed to an Array when the whole Document is the basis
			r = r + 1
			RangeList(r) = RangeName
			RangeBools(r) = True
		End If
	Wend
	AddSheetRanges = r
End Function



&apos; Fügt einen Bereich zur selektierten Kollektion hinzu
Sub SelectRange()
Dim i, a, s as Integer
Dim Listbox as Object
Dim RangeName as String
Dim SelItem as String
Dim LocRangeList(100) as String
Dim CurRange as String
Dim SheetRangeName as String
Dim DescriptionList(1) as String
Dim MaxRangeIndex, StatusValue as Integer

	StatusValue = 0
	MaxRangeIndex = Val(SelRangeList(0))
	Listbox = DialogModel.lstSelection
	a = 0
	CurSheetName = oSheet.Name
	For i = 1 To MaxRangeIndex
		SelItem = SelRangeList(i)
		&apos; Is the Range already included in the collection?
		oRange = RetrieveRangeoutOfRangename(SelItem)
		TotCellCount = TotCellCount + CountRangeCells(oRange)
		LocRangeList(a) = SelItem
		a = a + 1
		&apos; Der Listboxeintrag ist frisch selektiert worden und muß der Range - Kollektion 
		&apos; hinzugefügt werden
		DescriptionList() = ArrayOutofString(SelItem,&quot;.&quot;,1)
		SheetRangeName = DeleteStr(DescriptionList(0),&quot;&apos;&quot;)
		If SheetRangeName = CurSheetName Then
			oSelRanges.InsertbyName(&quot;&quot;,oRange)
		End If
		IncreaseStatusValue(SBRELGET/MaxRangeIndex)
	Next i
	
	&apos; Das Array mit den selektierten Listboxeinträgen aktualisieren
	ClearArray(ListboxItems())
	For s = 0 To a - 1
		CurRange = LocRangeList(s)
		ListboxItems(s) = CurRange
	Next s
End Sub


Sub ConvertThehardWay(ListboxList(), ThisSel(), SwitchFormat as Boolean, bAutopilot as Boolean)
Dim i, a, r as Integer
Dim AddCells as Long
Dim OldStatusValue as Single
Dim RangeName as String
Dim LastIndex as Integer

	Lastindex = Ubound(ListboxList())
	If TotCellCount &gt; 0 Then
		&apos; Index für die Removelist
		a = 0
		OldStatusValue = StatusValue
		&apos; Harte Formatierung
		For i = 0 To LastIndex
			If ThisSel(i) = True Then
				RangeName = ListboxList(i)
				oRange = RetrieveRangeoutofRangeName(RangeName)
				ConvertCellCurrencies(oRange, Currfactor, False, SwitchFormat)
				If NOT bAutoPilot Then
&apos; The following line has been put beside due to Bug #73157 (Two ranges lying side by side)
&apos;				If oSelRanges.HasbyName(RangeName) Then
					oSelRanges.RemovebyName(RangeName)
					oDocument.CurrentController.Select(oSelRanges)
&apos;				End If
				End If

				If SwitchFormat Then
					If oRange.getPropertyState(&quot;NumberFormat&quot;) &lt;&gt; 1 Then
						&apos; Range Ist hart formatiert
						SwitchNumberFormat(oRange, oFormats, sEuroSign)&apos; &quot;â‚¬&quot;)
					End If
				Else
					SwitchNumberFormat(oRange, oFormats, sEuroSign) &apos;&quot;â‚¬&quot;
				End If
				AddCells = CountRangeCells(oRange)
				CurCellCount = AddCells
				IncreaseStatusValue((CurCellCount/TotCellCount)*(100-OldStatusValue))

				&apos; Die selektierte Stilvorlage muÃŸ zum SchluÃŸ aus der Listbox entfernt werden
				If bPreSelected Then
					RemoveList(0) = ListboxList(i)
				Else
					r = IndexinArray(ListboxList(i), RangeList())
					If r &lt;&gt; -1 Then
						RangeBools(r) = False
						RemoveList(a) = RangeList(r)
						a = a + 1
					End If
				End If
			End If
		Next
	End If
End Sub



Sub ConvertCellCurrencies(oRange as Object, fFaktor as Double, CurrRoundMode, SwitchFormat as Boolean)
Dim oValues as Object
Dim IntValue as Long
Dim i as Integer
Dim CellValue as double
Dim oCells as Object
Dim oCell as Object
Dim DecFactor as integer
Dim nFormatDecimals as integer
Dim IsHardFormatted as Boolean

	&apos; Wenn der Bereich hart formatiert ist, dann bei selektierter
	&apos; weichen Formatierung keine Umrechnung

	&apos; konstante Werte im Bereich anpassen
  	oValues = oRange.queryContentCells( com.sun.star.sheet.CellFlags.VALUE )

	If (oValues.Count &gt; 0) Then
		oCells = oValues.Cells.createEnumeration
		While oCells.hasMoreElements
			oCell = oCells.nextElement
			DecFactor = 0
			CellValue = oCell.Value
			oCell.Value = CellValue/fFaktor
		Wend
	End If
End Sub


Function CheckIfRangeisCurrency(FormatObject as Object)
Dim oFormatofObject() as Object
	&apos; Retrieve the Format of the Object
	On Local Error GoTo NOKEY
	oFormatofObject() = oFormats.getByKey(FormatObject.NumberFormat)
	On Local Error GoTo 0			

	&apos; Typ und WÃ¤hrungssymbol des Numberformats heraussuchen
	&apos; Todo: ÃœberprÃ¼fe, ob diese beiden Zeilen nicht eleganter gehen
	 CheckIfRangeIsCurrency = INT(oFormatofObject.Type) AND com.sun.star.util.NumberFormat.CURRENCY
	Exit Function
NOKEY:
	CheckIfRangeisCurrency = False
	Resume CLERROR
	CLERROR:
End Function


Function CountColumnsForRow(IndexArray() as String, Row as Integer)
Dim i as Integer
Dim NoNulls as Boolean
	For i = 1 To Ubound(IndexArray,2)
		If IndexArray(Row,i)= &quot;&quot; Then
			NoNulls = False
			Exit For
		End If
	Next
	CountColumnsForRow = i
End Function


Function CountRangeCells(oRange as Object) As Long
Dim oRangeAddress as Object
Dim LocCellCount as Long
	oRangeAddress = oRange.RangeAddress
	LocCellCount = (oRangeAddress.EndColumn - oRangeAddress.StartColumn + 1) * (oRangeAddress.EndRow - oRangeAddress.StartRow + 1)
	CountRangeCells = LocCellCount
End Function
</script:module>