// autogenerated file with codegen.pl

#include <cppunit/simpleheader.hxx>

#include <basegfx/matrix/b2dhommatrix.hxx>
#include <basegfx/curve/b2dcubicbezier.hxx>
#include <basegfx/curve/b2dbeziertools.hxx>

#ifndef _SOLAR_H
#include <tools/solar.h> // F_PI definition, no link dependency
#endif

#include <iostream>

using namespace ::basegfx;
using namespace ::std;

namespace basegfx2d
{

class b2dbeziertools : public CppUnit::TestFixture
{
private:
    B2DCubicBezier aHalfCircle;                     // not exactly, but a look-alike
    B2DCubicBezier aQuarterCircle;                  // not exactly, but a look-alike
    B2DCubicBezier aLoop;                           // identical endpoints, curve goes back to where it started
    B2DCubicBezier aStraightLineDistinctEndPoints;  // truly a line
    B2DCubicBezier aStraightLineIdenticalEndPoints; // degenerate case of aLoop
    B2DCubicBezier aCrossing;                       // curve self-intersects somewhere in the middle
    B2DCubicBezier aCusp;                           // curve has a point of undefined tangency


public:
    // initialise your test code values here.
    void setUp()
    {
        const B2DPoint a00(0.0, 0.0);
        const B2DPoint a10(1.0, 0.0);
        const B2DPoint a11(1.0, 1.0);
        const B2DPoint a01(0.0, 1.0);
        const B2DPoint middle( 0.5, 0.5 );

        aHalfCircle     = B2DCubicBezier(a00, a01, a11, a10);

        // The spline control points become
        //
        //  (R * cos(A), R * sin(A))
        //  (R * cos(A) - h * sin(A), R * sin(A) + h * cos (A))
        //  (R * cos(B) + h * sin(B), R * sin(B) - h * cos (B))
        //  (R * cos(B), R * sin(B))
        //
        // where    h = 4/3 * R * tan ((B-A)/4)
        //
        // with R being the radius, A start angle and B end angle (A < B).
        //
        // (This calculation courtesy Carl Worth, himself based on
        // Michael Goldapp and Dokken/Daehlen)

        // Choosing R=1, A=0, B=pi/2
        const double h( 4.0/3.0 * tan(F_PI/8.0) );
        aQuarterCircle  = B2DCubicBezier(a10,
                                         B2DPoint( 1.0, h ),
                                         B2DPoint( h, 1.0),
                                         a01);

        aCusp           = B2DCubicBezier(a00, a11, a01, a10);

        aLoop           = B2DCubicBezier(a00, a01, a10, a00);

        aStraightLineDistinctEndPoints  = B2DCubicBezier(a00, middle, middle, a11);
        aStraightLineIdenticalEndPoints = B2DCubicBezier(a00, a11, a11, a00);
        aCrossing       = B2DCubicBezier(a00,
                                         B2DPoint(2.0,2.0),
                                         B2DPoint(-1.0,2.0),
                                         a10);

        cout << "#!/usr/bin/gnuplot -persist" << endl
             << "#" << endl
             << "# automatically generated by bezierclip, don't change!" << endl
             << "#" << endl
             << "set parametric" << endl
             << "bez(p,q,r,s,t) = p*(1-t)**3+q*3*(1-t)**2*t+r*3*(1-t)*t**2+s*t**3" << endl
             << "bezd(p,q,r,s,t) = 3*(q-p)*(1-t)**2+6*(r-q)*(1-t)*t+3*(s-r)*t**2" << endl
             << "pointmarkx(c,t) = c-0.03*t" << endl
             << "pointmarky(c,t) = c+0.03*t" << endl
             << "linex(a,b,c,t) = a*-c + t*-b" << endl
             << "liney(a,b,c,t) = b*-c + t*a" << endl << endl
             << "# end of setup" << endl << endl;

        cout << "# bezier subdivision" << endl
             << "plot [t=0:1] ";
        cout << " bez("
             << aHalfCircle.getStartPoint().getX() << ","
             << aHalfCircle.getControlPointA().getX() << ","
             << aHalfCircle.getControlPointB().getX() << ","
             << aHalfCircle.getEndPoint().getX()
             << ",t),bez("
             << aHalfCircle.getStartPoint().getY() << ","
             << aHalfCircle.getControlPointA().getY() << ","
             << aHalfCircle.getControlPointB().getY() << ","
             << aHalfCircle.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aQuarterCircle.getStartPoint().getX() << ","
             << aQuarterCircle.getControlPointA().getX() << ","
             << aQuarterCircle.getControlPointB().getX() << ","
             << aQuarterCircle.getEndPoint().getX()
             << ",t),bez("
             << aQuarterCircle.getStartPoint().getY() << ","
             << aQuarterCircle.getControlPointA().getY() << ","
             << aQuarterCircle.getControlPointB().getY() << ","
             << aQuarterCircle.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aCusp.getStartPoint().getX() << ","
             << aCusp.getControlPointA().getX() << ","
             << aCusp.getControlPointB().getX() << ","
             << aCusp.getEndPoint().getX()
             << ",t),bez("
             << aCusp.getStartPoint().getY() << ","
             << aCusp.getControlPointA().getY() << ","
             << aCusp.getControlPointB().getY() << ","
             << aCusp.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aLoop.getStartPoint().getX() << ","
             << aLoop.getControlPointA().getX() << ","
             << aLoop.getControlPointB().getX() << ","
             << aLoop.getEndPoint().getX()
             << ",t),bez("
             << aLoop.getStartPoint().getY() << ","
             << aLoop.getControlPointA().getY() << ","
             << aLoop.getControlPointB().getY() << ","
             << aLoop.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aStraightLineDistinctEndPoints.getStartPoint().getX() << ","
             << aStraightLineDistinctEndPoints.getControlPointA().getX() << ","
             << aStraightLineDistinctEndPoints.getControlPointB().getX() << ","
             << aStraightLineDistinctEndPoints.getEndPoint().getX()
             << ",t),bez("
             << aStraightLineDistinctEndPoints.getStartPoint().getY() << ","
             << aStraightLineDistinctEndPoints.getControlPointA().getY() << ","
             << aStraightLineDistinctEndPoints.getControlPointB().getY() << ","
             << aStraightLineDistinctEndPoints.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aStraightLineIdenticalEndPoints.getStartPoint().getX() << ","
             << aStraightLineIdenticalEndPoints.getControlPointA().getX() << ","
             << aStraightLineIdenticalEndPoints.getControlPointB().getX() << ","
             << aStraightLineIdenticalEndPoints.getEndPoint().getX()
             << ",t),bez("
             << aStraightLineIdenticalEndPoints.getStartPoint().getY() << ","
             << aStraightLineIdenticalEndPoints.getControlPointA().getY() << ","
             << aStraightLineIdenticalEndPoints.getControlPointB().getY() << ","
             << aStraightLineIdenticalEndPoints.getEndPoint().getY()
             << ",t),";
        cout << " bez("
             << aCrossing.getStartPoint().getX() << ","
             << aCrossing.getControlPointA().getX() << ","
             << aCrossing.getControlPointB().getX() << ","
             << aCrossing.getEndPoint().getX()
             << ",t),bez("
             << aCrossing.getStartPoint().getY() << ","
             << aCrossing.getControlPointA().getY() << ","
             << aCrossing.getControlPointB().getY() << ","
             << aCrossing.getEndPoint().getY()
             << ",t)," << endl;
    }

    void tearDown()
    {
    }

    void adaptiveSubdivideByDistance()
    {
        CPPUNIT_ASSERT_MESSAGE("identity", true );
    }

    void adaptiveSubdivideByAngle()
    {
        CPPUNIT_ASSERT_MESSAGE("identity", true );
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dbeziertools);
    CPPUNIT_TEST(adaptiveSubdivideByDistance);  // TODO: add tests for quadratic bezier (subdivide and degree reduction)
    CPPUNIT_TEST(adaptiveSubdivideByAngle);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dcubicbezier


class b2dcubicbezier : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        // this is demonstration code
        // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
        CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dcubicbezier);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dcubicbezier


class b2dhommatrix : public CppUnit::TestFixture
{
private:
    B2DHomMatrix    maIdentity;
    B2DHomMatrix    maScale;
    B2DHomMatrix    maTranslate;
    B2DHomMatrix    maShear;
    B2DHomMatrix    maAffine;
    B2DHomMatrix    maPerspective;

public:
    // initialise your test code values here.
    void setUp()
    {
        // setup some test matrices
        maIdentity.identity(); // force compact layout
        maIdentity.set(0,0, 1.0);
        maIdentity.set(0,1, 0.0);
        maIdentity.set(0,2, 0.0);
        maIdentity.set(1,0, 0.0);
        maIdentity.set(1,1, 1.0);
        maIdentity.set(1,2, 0.0);

        maScale.identity(); // force compact layout
        maScale.set(0,0, 2.0);
        maScale.set(1,1, 20.0);

        maTranslate.identity(); // force compact layout
        maTranslate.set(0,2, 20.0);
        maTranslate.set(1,2, 2.0);

        maShear.identity(); // force compact layout
        maShear.set(0,1, 3.0);
        maShear.set(1,0, 7.0);
        maShear.set(1,1, 22.0);

        maAffine.identity(); // force compact layout
        maAffine.set(0,0, 1.0);
        maAffine.set(0,1, 2.0);
        maAffine.set(0,2, 3.0);
        maAffine.set(1,0, 4.0);
        maAffine.set(1,1, 5.0);
        maAffine.set(1,2, 6.0);

        maPerspective.set(0,0, 1.0);
        maPerspective.set(0,1, 2.0);
        maPerspective.set(0,2, 3.0);
        maPerspective.set(1,0, 4.0);
        maPerspective.set(1,1, 5.0);
        maPerspective.set(1,2, 6.0);
        maPerspective.set(2,0, 7.0);
        maPerspective.set(2,1, 8.0);
        maPerspective.set(2,2, 9.0);
    }

    void tearDown()
    {
    }

    void equal()
    {
        B2DHomMatrix    aIdentity;
        B2DHomMatrix    aScale;
        B2DHomMatrix    aTranslate;
        B2DHomMatrix    aShear;
        B2DHomMatrix    aAffine;
        B2DHomMatrix    aPerspective;

        // setup some test matrices
        aIdentity.identity(); // force compact layout
        aIdentity.set(0,0, 1.0);
        aIdentity.set(0,1, 0.0);
        aIdentity.set(0,2, 0.0);
        aIdentity.set(1,0, 0.0);
        aIdentity.set(1,1, 1.0);
        aIdentity.set(1,2, 0.0);

        aScale.identity(); // force compact layout
        aScale.set(0,0, 2.0);
        aScale.set(1,1, 20.0);

        aTranslate.identity(); // force compact layout
        aTranslate.set(0,2, 20.0);
        aTranslate.set(1,2, 2.0);

        aShear.identity(); // force compact layout
        aShear.set(0,1, 3.0);
        aShear.set(1,0, 7.0);
        aShear.set(1,1, 22.0);

        aAffine.identity(); // force compact layout
        aAffine.set(0,0, 1.0);
        aAffine.set(0,1, 2.0);
        aAffine.set(0,2, 3.0);
        aAffine.set(1,0, 4.0);
        aAffine.set(1,1, 5.0);
        aAffine.set(1,2, 6.0);

        aPerspective.set(0,0, 1.0);
        aPerspective.set(0,1, 2.0);
        aPerspective.set(0,2, 3.0);
        aPerspective.set(1,0, 4.0);
        aPerspective.set(1,1, 5.0);
        aPerspective.set(1,2, 6.0);
        aPerspective.set(2,0, 7.0);
        aPerspective.set(2,1, 8.0);
        aPerspective.set(2,2, 9.0);

        CPPUNIT_ASSERT_MESSAGE("operator==: identity matrix", aIdentity == maIdentity);
        CPPUNIT_ASSERT_MESSAGE("operator==: scale matrix", aScale == maScale);
        CPPUNIT_ASSERT_MESSAGE("operator==: translate matrix", aTranslate == maTranslate);
        CPPUNIT_ASSERT_MESSAGE("operator==: shear matrix", aShear == maShear);
        CPPUNIT_ASSERT_MESSAGE("operator==: affine matrix", aAffine == maAffine);
        CPPUNIT_ASSERT_MESSAGE("operator==: perspective matrix", aPerspective == maPerspective);
    }

    void identity()
    {
        B2DHomMatrix ident;

        CPPUNIT_ASSERT_MESSAGE("identity", maIdentity == ident);
    }

    void scale()
    {
        B2DHomMatrix mat;
        mat.scale(2.0,20.0);
        CPPUNIT_ASSERT_MESSAGE("scale", maScale == mat);
    }

    void translate()
    {
        B2DHomMatrix mat;
        mat.translate(20.0,2.0);
        CPPUNIT_ASSERT_MESSAGE("translate", maTranslate == mat);
    }

    void shear()
    {
        B2DHomMatrix mat;
        mat.shearX(3.0);
        mat.shearY(7.0);
        CPPUNIT_ASSERT_MESSAGE("translate", maShear == mat);
    }

    void multiply()
    {
        B2DHomMatrix affineAffineProd;

        affineAffineProd.set(0,0, 9);
        affineAffineProd.set(0,1, 12);
        affineAffineProd.set(0,2, 18);
        affineAffineProd.set(1,0, 24);
        affineAffineProd.set(1,1, 33);
        affineAffineProd.set(1,2, 48);

        B2DHomMatrix affinePerspectiveProd;

        affinePerspectiveProd.set(0,0, 30);
        affinePerspectiveProd.set(0,1, 36);
        affinePerspectiveProd.set(0,2, 42);
        affinePerspectiveProd.set(1,0, 66);
        affinePerspectiveProd.set(1,1, 81);
        affinePerspectiveProd.set(1,2, 96);
        affinePerspectiveProd.set(2,0, 7);
        affinePerspectiveProd.set(2,1, 8);
        affinePerspectiveProd.set(2,2, 9);

        B2DHomMatrix perspectiveAffineProd;

        perspectiveAffineProd.set(0,0, 9);
        perspectiveAffineProd.set(0,1, 12);
        perspectiveAffineProd.set(0,2, 18);
        perspectiveAffineProd.set(1,0, 24);
        perspectiveAffineProd.set(1,1, 33);
        perspectiveAffineProd.set(1,2, 48);
        perspectiveAffineProd.set(2,0, 39);
        perspectiveAffineProd.set(2,1, 54);
        perspectiveAffineProd.set(2,2, 78);

        B2DHomMatrix perspectivePerspectiveProd;

        perspectivePerspectiveProd.set(0,0, 30);
        perspectivePerspectiveProd.set(0,1, 36);
        perspectivePerspectiveProd.set(0,2, 42);
        perspectivePerspectiveProd.set(1,0, 66);
        perspectivePerspectiveProd.set(1,1, 81);
        perspectivePerspectiveProd.set(1,2, 96);
        perspectivePerspectiveProd.set(2,0, 102);
        perspectivePerspectiveProd.set(2,1, 126);
        perspectivePerspectiveProd.set(2,2, 150);

        B2DHomMatrix temp;

        temp = maAffine;
        temp*=maAffine;
        CPPUNIT_ASSERT_MESSAGE("multiply: both compact", temp == affineAffineProd);

        temp = maPerspective;
        temp*=maAffine;
        CPPUNIT_ASSERT_MESSAGE("multiply: first compact", temp == affinePerspectiveProd);

        temp = maAffine;
        temp*=maPerspective;
        CPPUNIT_ASSERT_MESSAGE("multiply: second compact", temp == perspectiveAffineProd);

        temp = maPerspective;
        temp*=maPerspective;
        CPPUNIT_ASSERT_MESSAGE("multiply: none compact", temp == perspectivePerspectiveProd);
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dhommatrix);
    CPPUNIT_TEST(equal);
    CPPUNIT_TEST(identity);
    CPPUNIT_TEST(scale);
    CPPUNIT_TEST(translate);
    CPPUNIT_TEST(shear);
    CPPUNIT_TEST(multiply);
    CPPUNIT_TEST_SUITE_END();

}; // class b2dhommatrix


class b2dhompoint : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dhompoint);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dhompoint


class b2dpoint : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    // this is only demonstration code
    void EmptyMethod()
    {
          // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
       CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dpoint);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dpoint


class b2dpolygon : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        CPPUNIT_ASSERT_STUB();
    }
    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dpolygon);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dpolygon


class b2dpolygontools : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    // this is only demonstration code
    void EmptyMethod()
    {
          // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
       CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dpolygontools);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dpolygontools


class b2dpolypolygon : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dpolypolygon);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dpolypolygon


class b2dquadraticbezier : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    // this is only demonstration code
    void EmptyMethod()
    {
          // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
       CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dquadraticbezier);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dquadraticbezier


class b2drange : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2drange);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2drange


class b2dtuple : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    // this is only demonstration code
    void EmptyMethod()
    {
          // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
       CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dtuple);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dtuple


class b2dvector : public CppUnit::TestFixture
{
public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void EmptyMethod()
    {
        CPPUNIT_ASSERT_STUB();
    }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(b2dvector);
    CPPUNIT_TEST(EmptyMethod);
    CPPUNIT_TEST_SUITE_END();
}; // class b2dvector

// -----------------------------------------------------------------------------
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dbeziertools, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dcubicbezier, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dhommatrix, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dhompoint, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dpoint, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dpolygon, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dpolygontools, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dpolypolygon, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dquadraticbezier, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2drange, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dtuple, "basegfx2d");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::b2dvector, "basegfx2d");
} // namespace basegfx2d


// -----------------------------------------------------------------------------

// this macro creates an empty function, which will called by the RegisterAllFunctions()
// to let the user the possibility to also register some functions by hand.
// NOADDITIONAL;

