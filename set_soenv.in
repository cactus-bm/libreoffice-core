#!@PERL@ -w  # -*- Mode: perl; tab-width: 4; indent-tabs-mode: nil; -*-
#
# Program:     set_soenv.in
# Author:      Willem van Dorp, Ross Nicholson, Oisin Boydell - Sun Microsystems, Ireland.
#
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Description:
# set_soenv generates a file that contains all necessary
# environment variables for the build proces of OpenOffice
# on Linux, NetBSD, Solaris, Windows, Mac OS X and iOS.
#
# Program steps.
#
# I.    Checking the command-line arguments.
# IIa.  Declaring variables for the system commands, etc.
# IIb.  Declaring the environment variables.
# III.  Initialising the variables for the system commands, etc.
# IV.   Print out some important messages etc.
# V.    Initialising the environment variables.
# VI.   Open the output file.
# VII.  Writing the data to the output file.
# VIII. Closing output file.
#
#---------------------------------------------------------------------------
#
use strict;                        # pragma
use File::Basename;


#
#--------------------------------------------------------
# IIa. Declaring variables for the system commands, etc.
#--------------------------------------------------------
#
my ( $outfile, $newline, $comment,
     $ds, $ps,
     $wps, $cur_dir, $par_dir, $tmp,
     $platform,
     $empty,
     $warnfile, $Warning, $result, $unsetvars, $exportvars);
#
#-------------------------------------------------
# IIb. Declaring environment values (constants).
#-------------------------------------------------
#
# Platform independent constant values.
my ( $CC );
#
# Platform dependent constant values.
my (
      $OUTPATH, $INPATH,
      );
#
#-------------------------------------------
# IIc. Declaring the environment variables.
#-------------------------------------------
#
# Help variables.
my ( $BIN, $LIB,
     $ASM_PATH, $PERL_PATH, $CL_X64 );

# Environment variables.
my ( $oldPATH, $SRC_ROOT, $JAVA_HOME, $JDK,
     $UPD,
     $SOLARENV,
     $CLASSPATH, $XCLASSPATH, $COMPATH,
     $MSPDB_PATH, $MIDL_PATH, $CSC_PATH, $SHOWINCLUDES_PREFIX,
     $PATH,
     $PERL,
     $COMP_ENV, $JAVAHOME, $WINDOWS_SDK_HOME, $DIRECTXSDK_LIB, $DOTNET_FRAMEWORK_HOME,
     $TMPDIR,
     $GNUMAKE,
     );
#
#-------------------------------------------
# IId. Declaring the aliases.
#-------------------------------------------
#
my ( $dmake, $build, $mkout, $deliver, $zipdep );
#

$INPATH="@INPATH@";
$OUTPATH="@OUTPATH@";
$COMPATH="@COMPATH@";
#-------------------------------------------------------------
# IIIa. Initialising constants.
#-------------------------------------------------------------
#
# $platform is needed for PathFormat()
#
$platform       = '@host@';

$UPD            = '@UPD@';          # the project's UPD
$newline        = "\n";             # Perl newline character
$ds             = "/";              # directory separator
$ps             = ":";              # path separator
$wps            = ":";              # path separator, will be set to ';' for windows later.
$cur_dir        = ".";              # current directory
$par_dir        = "..";             # parrent directory
$empty          = "";               # used as argument
$warnfile       = "warn";           # logfile configure warnings.
$Warning        = "";               # container for warning messages
$JDK 		= '@JDK@';
$CC             = '@CC@';            # C compiler
$CL_X64 = '@CL_X64@';
$GNUMAKE        = "@GNUMAKE@";

# JAVA_HOME as argument from autoconf.
$JAVA_HOME = PathFormat('@JAVA_HOME@') ;

if ( $platform =~ m/cygwin/ ) {
   $JAVA_HOME =~ s/[\s\/]+$//;	# remove trailing \n or \/ if there is any.
}
#
#--------------------------------------------------------------------
# IV. Initialise the warning container and print a note to the user.
#--------------------------------------------------------------------
#
# Add the configure (pre-requisite) warnings to the warning container
# , $Warning.
AddWarning( "configure", "" );
#
print ("Setting up the environment for building LibreOffice $newline");
#
#--------------------------------------------------
# V. Setting the environment variables/values.
#--------------------------------------------------
#

#
# B. Gathering information from the system.
#
# 1. Path
$oldPATH = $ENV{"PATH"};
chomp( $oldPATH );                  # cut off new line
#
# C. Setting the constant values.
#
# Setting platform independent constant values.
$comment              = "#";           # UNIX script comment character

# Setting platform dependent constant values.
if ( $platform =~ m/cygwin|mingw32/ )
{
    $MSPDB_PATH     = PathFormat('@MSPDB_PATH@');
    $MIDL_PATH      = PathFormat('@MIDL_PATH@');
    $CSC_PATH       = PathFormat('@CSC_PATH@');
    $SHOWINCLUDES_PREFIX = '@SHOWINCLUDES_PREFIX@';
    $WINDOWS_SDK_HOME      = "@WINDOWS_SDK_HOME@";
    $DOTNET_FRAMEWORK_HOME = PathFormat('@DOTNET_FRAMEWORK_HOME@');
    $wps = ';' if '@build_os@' eq 'cygwin'; # Windows style path seperator
}


print "done\n";

#
# D. Gathering directory information from the user.
#
# If the directory does not exist something is strange.
# 1. LibreOffice build home directory.
# SRC_ROOT should already be in the env due to config_host.mk
$SRC_ROOT = $ENV{"SRC_ROOT"};
CheckPathExist( $SRC_ROOT );


# ml.exe assembler path for Windows users.
if ($platform =~ m/cygwin/)
{
    $ASM_PATH = PathFormat('@ASM_HOME@');
}

#
# E. Determining the envionment values based on the information
#    that was gathered earlier on.

$BIN                  = $ds."bin";
$LIB                  = $ds."lib";

$PERL                 = PathFormat('@PERL@'); # Perl program
$PERL_PATH            = dirname('@PERL@'); # Perl Path

#
$SOLARENV             = PathFormat("$SRC_ROOT/solenv");

# Location of JDK classes .zip file.
# but in jdk 1.2 it is called rt.jar and it lives in jre/lib
$CLASSPATH            = '';
$CLASSPATH           .= $JAVA_HOME.$ds.'jre'.$LIB.$ds."rt.jar" if (-f $JAVA_HOME.$ds.'jre'.$LIB.$ds."rt.jar");
$CLASSPATH           .= $wps.'.' if ($CLASSPATH ne '');

# Why do we need XCLASSPATH when it has the exact same value as CLASSPATH?
$XCLASSPATH           = $CLASSPATH;


# Windows NT only variables
if ($platform =~ m/cygwin/)
{

   $JAVAHOME          = $JAVA_HOME;

}

# The general environment path.
if ($platform =~ m/linux|netbsd|freebsd|aix|solaris|openbsd|dragonfly/)
{  $PATH              = $cur_dir.
                        $ps.'$SOLARENV'.$ds.'$OUTPATH'.$BIN.
                        $ps.'$SOLARENV'.$BIN;

   if ($platform =~ m/solaris/) {
	$PATH .= $ps."/usr/ccs/bin";
   }

   $PATH             .= $ps.$oldPATH;

   my @javaBits;
   if ( $JAVA_HOME ne "" && $JAVA_HOME ne "NO_JAVA_HOME"  &&  $JDK ne "gcj" ) {
      @javaBits = ( $JAVA_HOME.$BIN, 'javac' );
   } else {
      @javaBits = ();
   }
   $PATH              = GetCorrectPath ($PATH,
                                        $COMPATH, $CC,
                                        $PERL_PATH, 'perl',
                                        @javaBits);
}

elsif ($platform =~ m/cygwin/)
{  # The PATH variable is completely created from scratch. Elements
   # from oldPATH that are not yet included are appended to PATH at
   # the end.

   my ( $tmppath );

   $PATH              = $cur_dir.
                        $ps.CygFormat($SOLARENV).$ds."bin".
                        $ps.CygFormat($SOLARENV).$ds.$OUTPATH.$BIN;

   if ( $JAVA_HOME ne "" && $JAVA_HOME ne "NO_JAVA_HOME" )
   {
      # hack either "hotspot" or "client" should be used, depending on the jdk version:
      # 1.2.x   -   no such directory, unsupported
      # 1.3.x   -   hotspot, client missing
      # 1.4.x   -   client, hotspot missing

      $PATH .= $ps.CygFormat($JAVA_HOME).$BIN;
	  if ( -d $JAVA_HOME.$ds."jre".$ds."bin".$ds."hotspot" ) {
		  $PATH .= $ps.CygFormat($JAVA_HOME).$ds."jre".$ds."bin".$ds."hotspot";
	  }
	  if ( -d $JAVA_HOME.$ds."jre".$ds."bin".$ds."client" ) {
		  $PATH .= $ps.CygFormat($JAVA_HOME).$ds."jre".$ds."bin".$ds."client";
	  }
   }

   # Add path to compiler
   $tmppath = CygFormat($COMPATH).$BIN;
   $tmppath .= $ds."amd64" if $CL_X64;
   $tmppath =~ s/^\/\//\//;
   if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
       $PATH .= $ps.$tmppath;
   }

    $tmppath = CygFormat($MSPDB_PATH);
    # for MSVC to find mspdb*.dll
    if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
        $PATH .= $ps.$tmppath;
    }
    # need midl.exe
    $tmppath = CygFormat($MIDL_PATH);
    if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
        $PATH .= $ps.$tmppath;
    }
    # needs csc.exe
    $tmppath = CygFormat($CSC_PATH);
    if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
        $PATH .= $ps.$tmppath;
    }
    # Installer needs some files if the Windows Installer SDK
    $tmppath = CygFormat($WINDOWS_SDK_HOME);
    if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath\/bin)(?:[:]|\Z)/i ) {
        $PATH .= $ps.$tmppath.$BIN;
    }

   if ( $ASM_PATH ne "ASM_IN_PATH" )
   {   $PATH          .= $ps.CygFormat($ASM_PATH);
   }

   # Possible cygwin paths must follow behind the OOo and MS paths.
   # What the above comment means I have no idea.

   # Check if $PERL_PATH is already set in PATH
   $tmppath = CygFormat($PERL_PATH);
   if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
      $PATH          .= $ps.$tmppath;
   }
   # path to sn.exe (signing) for Windows users.
   my $sn_path = PathFormat('@DOTNET_FRAMEWORK_HOME@/bin');
   $tmppath = CygFormat($sn_path);
   if ( "$PATH:$oldPATH" !~ /(?:[:]|\A)(?:$tmppath)(?:[:]|\Z)/ ) {
       $PATH          .= $ps.$tmppath;
   }

   # Add the rest of the original path if it is still missing.
   my $expandedPATH = $PATH;
   $expandedPATH =~ s/(\$\w+)/$1/eeg;

   # fix situations where PATH may look like /bin:"C:\blah\bleh":/ugh
   my $fixedPATH = $oldPATH;
   if ( $oldPATH =~ /"/ ) {
   $fixedPATH = "";
   foreach my $pathentry ( split( '"',$oldPATH ) ) {
       if ( ( $pathentry =~ /^$ps/ ) || ( $pathentry =~ /$ps$/ ) ) {
       $fixedPATH .= $pathentry;
       } else {
       chomp( $pathentry = qx{cygpath -d "$pathentry"} ) ;
       chomp( $pathentry = qx{cygpath -u "$pathentry"} ) ;
       $fixedPATH .= $pathentry;
       }
   }
   }

   foreach my $pathentry (split($ps,$fixedPATH)) {
       if ( ! ( $expandedPATH =~ /(?:$ps|\A)(?:$pathentry)(?:$ps|\Z)/ ) ) {
           $PATH .= $ps.$pathentry;
           $expandedPATH .= $ps.$pathentry;
       }
   }

   # The path now is in cygwin posix format

}
elsif ($platform =~ m/mingw32/)
{
   my ( $tmppath );

   $PATH              = $cur_dir.
                        $ps.CygFormat($SOLARENV).$ds."bin".
                        $ps.CygFormat($SOLARENV).$ds.$OUTPATH.$BIN;

   $PATH              .= $ps.$oldPATH;
}
elsif ($platform =~ m/darwin/)
{  $PATH              = $cur_dir.
                        $ps.'$SOLARENV'.$ds.'$OUTPATH'.$BIN.
                        $ps.'$SOLARENV'.$BIN;

  # Append old PATH
  $PATH             .= $ps.$oldPATH;
}
else
{  AddWarning( "set_soenv", "$platform not configured for general environment paths" );
}


#
# F. Setting the different aliases.
#
# 1. alias for a full product make.
	$mkout           = '"perl $SOLARENV/bin/mkout.pl"';
	$deliver         = '"perl $SOLARENV/bin/deliver.pl"';
	$build           = '"perl $SOLARENV/bin/build.pl"';
	$zipdep          = '"perl $SOLARENV/bin/zipdep.pl"';

#
#--------------------------
# VI. Open the output file.
#--------------------------
#
$outfile = 'Env.Host.sh';

open( OUT, ">$SRC_ROOT/$outfile" ) ||
   die "Cannot open $SRC_ROOT/$outfile: $!\n";

#
#------------------------------------------
# VII. Writing the data to the output file.
#------------------------------------------
#
# Write file header.
CreateFileHeader( *OUT, $UPD, $platform, "sh/bash/ksh", "#" );

ToFile( "JAVA_HOME",         $JAVA_HOME,         "e" );

if ( $platform =~ m/cygwin/ )
{

   # Hack around dmake's mktmp not generating DOS paths.
   my $tmpdir = qx{cygpath -m "/tmp"};
   chomp($tmpdir);
   ToFile( "TMPDIR",     $tmpdir,            "e" );
   if ( !defined $ENV{"TMP"} || $ENV{"TMP"} eq "" ) {
      ToFile( "TMP", $tmpdir, "e" );
   } else {
      ToFile( "TMP", "$ENV{'TMP'}", "e" );
   }
}
else
{
   if ( !defined $ENV{"TMPDIR"} || $ENV{"TMPDIR"} eq "" ) {
      ToFile( "TMPDIR",      "/tmp",               "e" );
   } else {
      ToFile( "TMPDIR",      "$ENV{'TMPDIR'}",     "e" );
   }
}

ToFile( "PERL",              $PERL,              "e" );
ToFile( "SOLARENV",          $SOLARENV,          "e" );
if ( $JDK ne "gcj" ) {
   ToFile( "CLASSPATH",         $CLASSPATH,         "e" );
   ToFile( "XCLASSPATH",        $XCLASSPATH,        "e" );
   ToFile( "JAVACISKAFFE",     '@JAVACISKAFFE@',    "e" );
}
else {
   ToFile( "JAVACISGCJ",       '@JAVACISGCJ@',      "e" );
}

if ( '@CROSS_COMPILING@' eq 'YES' )
{
   # Obviously we shouldn't set PATH to contain host binaries
   ToFile( "PATH",           "@PATH_FOR_BUILD@", "e" );
}
else
{
   ToFile( "PATH",           $PATH,              "e" );
   ToFile( "PATH_FOR_BUILD",    $PATH,           "e" );
}
ToFile( "JAVAHOME",          $JAVAHOME,          "e" );


#
# Writing the aliases to file.
ToFile( "Aliases.",          $empty,             "c" );
ToFile( "Don't set aliases when bootstrapping", $empty, "c" );

ToFile( "alias mkout",       $mkout,             "a" );
ToFile( "alias deliver",     $deliver,           "a" );
ToFile( "alias build",       $build,             "a" );
ToFile( "alias zipdep",      $zipdep,            "a" );

#
# Writing unset variables you might not need to file.
#
print OUT "export $exportvars$newline";
print OUT "unset $unsetvars$newline";
# unset may return a non-zero value and make the initial
# make(1) processes terminate with an error
print OUT "true $newline";

#
#---------------------------
# VIII. Closing output file.
#---------------------------
#
close( OUT ) || print "Can't close $SRC_ROOT/$outfile: $!";

#--------------------------------------------------------
# XII. Message at the end.
#--------------------------------------------------------
#
#
print "$newline";
print "*********************************************************".
      "*******************$newline*$newline";
print "* LibreOffice configuration finished. $newline*$newline";

if ( $Warning ne "" )
{  print "$Warning*$newline";
}

print "*********************************************************".
      "******************* $newline";

print "To build, issue:\n$GNUMAKE\n\n";
print "To install when the build is finished, issue:\n$GNUMAKE install\n\n";
print "If you want to develop LibreOffice, you might prefer:\n$GNUMAKE dev-install\n\n";
print "If you want to run the smoketest, issue:\n$GNUMAKE check\n\n";

if ("@STALE_MAKE@" eq "TRUE" && $platform =~ m/cygwin/ ) {
print << 'EOS'
WARNING:
Your make version is known to be horribly slow, and hard to debug
problems with. To get a reasonably functional make please do:

to install a pre-compiled binary make for cygwin

mkdir -p /opt/lo/bin
cd /opt/lo/bin
wget http://dev-www.libreoffice.org/bin/cygwin/make
chmod +x make

to install from source:
place yourself in a working directory of you choice.

git clone git://anongit.freedesktop.org/libreoffice/contrib/dev-tools
cd dev-tools/make-3.82-gbuild
./configure --prefix=/opt/lo
make
sudo make install

Then re-run autogen.sh

Note: autogen.sh will try to use /opt/lo/bin/make if the environment variable GNUMAKE is not already defined.
Alternatively, you can install the 'new' make where ever you want and make sure that `which make` finds it.

EOS
}

if ( $Warning ne "" ) {
	print "***** WARNINGS ISSUED *****\n";
}

#
#-----------------
# XII. Functions.
#-----------------
#
#-------------------------------------------------------------
# Function name: CheckPathName
# Description:   chops off the '/' character if it's the last
#                character in a pathname. also adds the '/'
#                character if it's not the first character
#                in a path.
# Arguments:     1. Path (string)
# Return value:  Path (string)
#-------------------------------------------------------------
sub CheckPathName
{  my $retrn = $_[ 0 ];
   if ($platform =~ m/cygwin/)
   {  # Check if the first character is not a '/'.
      if ( !( $_[ 0 ] =~ /^\// ) )
      {  $retrn = $ds.$_[ 0 ];
      }
   }
   # kill the last '/','\','\n' if they exists.
   $retrn =~ s![\s/\\]+$!!;
   # Done!
   return( $retrn );
}
#-------------------------------------------------------------
# Function name: CheckPathExist
# Description:   Checks whether the directory that is given
#                as an argument exists. If not abort.
# Arguments:     1. Path (string)
# Return value:  void
#-------------------------------------------------------------
sub CheckPathExist
{  my $dir = $_[ 0 ];
   if ( !( -d $dir ) )
   {  print ( "The directory $_[ 0 ] does not exist. Please create first.\n" );
      exit 1;
   }
   else
   {  # Don't check under ActiveState Perl (Windows). The path is possibly
      # posix and it cannot handle it.
      # Hmm, but the above test also checks for existance, so presumably
      # the mention of ActiveState in the above comment is just a red
      # herring.
      return "true";
   }
}
#------------------------------------------------------------
# Function name: CreateFileHeader
# Description:   Creates a header for the outfile.
# Arguments:     1. File to write to
#                2. UPD (string)
#                3. Platform (string)
#                4. name of shell for this file
#                5. comment to use for this file
# Return value:  void
#------------------------------------------------------------
sub CreateFileHeader
{  my $timestamp = `date`;
   chomp( $timestamp );
   my $filehandle = $_[0];
   my $comment = $_[4];
   print { $filehandle } "$comment #################################################################";
   print { $filehandle } $newline;
   print { $filehandle } "$comment LibreOffice $_[ 1 ] build environment file for: $_[ 2 ]. $newline";
   print { $filehandle } "$comment Generated on: $timestamp $newline";
   print { $filehandle } "$comment Source this file to set up the build environment. $newline";
   print { $filehandle } "$comment 1. exec $_[3] $newline";
   print { $filehandle } "$comment 2. source $outfile $newline";
   print { $filehandle } "$comment #################################################################";
   print { $filehandle } $newline;
   print { $filehandle } 'if test -z "$SRC_ROOT" ; then';
   print { $filehandle } $newline;
   print { $filehandle } " . $SRC_ROOT/config_host.mk $newline";
   print { $filehandle } "fi $newline";
   print { $filehandle } $newline;
}
#---------------------------------------------------------
# Function name: ToFile
# Description:   Writes the environment variable in the
#                output file.
# Arguments:     1. Name of environment variable (string)
#                2. Value of environment variable (string)
#                3. e - env. var
#                   a - alias
#                   c - comment
#                   n - newline
#                   z - raw, write as is to OUT
# Return value:  void
#---------------------------------------------------------
sub ToFile {
   if ( $_[ 2 ] eq "e" ) {
      # Write an environment variable to file.
      if (defined $_[ 1 ] && $_[ 1 ] ne "" ) {
         my $envvar = $_[ 1 ];

         # Tcsh/bash needs backslashes quoted
         $envvar =~ s/\\/\\\\/g;

         printf("%-12s %-17s %-10s %s\n", "The variable", $_[ 0 ], "is set to:", $envvar) if ( '@VERBOSE@' eq 'TRUE' );
         print OUT "$_[ 0 ]=\"$envvar\"$newline";      # to sh file
         $exportvars .= " $_[ 0 ]";                        # add to export list for sh file

      } else {
         printf("%-12s %-17s %-10s %s\n", "The variable", $_[ 0 ], "is set to:", "unset") if ( '@VERBOSE@' eq 'TRUE' );
         $unsetvars .= " $_[ 0 ]";                             # for sh file
      }
   }
   elsif ( $_[ 2 ] eq "a" )
   {  # Write an alias to file.
      print "The $_[ 0 ] is set to: $_[ 1 ]\n" if ( '@VERBOSE@' eq 'TRUE' );    # to stdout
      print OUT "$_[ 0 ]=$_[ 1 ]$newline";      # to sh file
   }
   elsif ( $_[ 2 ] eq "c" )
   {  # Write a comment to file.
      if ( '@VERBOSE@' eq 'TRUE' )
      {
         print "$newline";
         print "$comment$newline";
         print "$comment $_[ 0 ]$newline";
         print "$comment$newline";
      }
      print OUT "$newline";
      print OUT "$comment$newline";
      print OUT "$comment $_[ 0 ]$newline";
      print OUT "$comment$newline";
   }
   elsif ( $_[ 2 ] eq "n" )
   {  #Write a newline to a file
      print OUT "$newline";
   }
   elsif ( $_[ 2 ] eq "z" )
   {
      #Write first argument as is, and nothing else
      print OUT "$_[ 0 ]$newline";
   }
   else
   {  print "Unknown type!$newline";
   }
}
#----------------------------------------------------------
# Function name: PathFormat
# Description:   Reformat path to either POSIX or mixed mode style.
# Arguments:     1. Variable (string)
# Return value:  Reformatted String
#----------------------------------------------------------
sub PathFormat
{  my ( $variable, $d1, $d2 );
   $variable = $_[ 0 ];

   if ( $platform =~ m/cygwin/ )
   {   $variable =~ s/(\$\{?\w+\}?)/$1/eeg ; # expand the variables
       $variable =~ s/(\$\{?\w+\}?)/$1/eeg ; # expand the variables twice!

       # Complain if PosixPath is used on a PATH-like string
       if ( $variable =~ m/;/ ) {
           die( "Do not use on PATH lists (i.e., 'c:\\foo;d:\\bar')");
       }

       # Replace path with space with short dos path
       if ( $variable =~ / / ) {
           chomp( $variable = qx{cygpath -d "$variable"} ) ;
       }

       # Replace absolute paths or DOS paths with ...
       if ( ( $variable =~ m/^\// ) or ( $variable =~ m/:/ ) ) {
           # mixed mode paths
           chomp( $variable = qx{realpath "$variable"} ) unless ($variable =~ m/:/);
           chomp( $variable = qx{cygpath -m "$variable"} );
       }
   }
   return $variable;
}
#----------------------------------------------------------
# Function name: CygFormat
# Description:   Format variables to cygwin posix style path
#                unless .
# Arguments:     1. Variable (string)
# Return value:  Reformatted String
#----------------------------------------------------------
sub CygFormat
{  my ( $variable, $d1, $d2 );
   $variable = $_[ 0 ];
   # ToDo: Do the replacement only if Windows and var contains "\" and ":"
   if ( $platform =~ m/cygwin/ )
   {
       # Complain if PosixPath is used on a PATH-like string
       if ( $variable =~ m/;/ ) {
           die( "Do not use on PATH lists (i.e., 'c:\\foo;d:\\bar')");
       }

       # Replace DOS paths with posix paths
       if ( ( $variable =~ m/\\/ ) or ( $variable =~ m/:/ ) ) {
           chomp( $variable = qx{cygpath -u "$variable"} );
       }
   }
   return $variable;
}
#----------------------------------------------------------
# Function name: WinPath
# Description:   Reformat a $sep seperated path using DOS paths.
# Arguments:     1. Variable (string)
#                2. Separaror (string)
# Return value:  Reformatted String
#----------------------------------------------------------
sub WinPath
{
    my ( $variable, $d1, $sep, @split_var );

    if ( $platform =~ m/cygwin/ ) {
        $variable = $_[ 0 ];
        $sep = $_[ 1 ];
        $variable =~ s/^\s+//g ; #remove leading spaces
        $variable =~ s/\s+$//g ; #remove trailing spaces
        $variable =~ s/(\$\{?\w+\}?)/$1/eeg ; # expand the variables
        $variable =~ s/(\$\{?\w+\}?)/$1/eeg ; # expand the variables twice!

        @split_var = split(/$sep/,$variable);
        foreach $d1 ( @split_var ) {
            if ( $d1 =~ /(?:^\/[\w\.~ ]+)+/ ) {
                if ( $d1 =~ / / ) {
                    # Use DOS 8.3 style to avoid quoting
                    chomp( $d1 = qx{cygpath -d "$d1"} );
                } else {
                    # Use "normal" filenames
                    chomp( $d1 = qx{cygpath -w "$d1"} );
                }
            }
        }
        $variable = join(';',@split_var);

        $variable =~ s/\//\\/g; # Remaining \ come from e.g.: ../foo/baa
    }

    return $variable;
}

#--------------------------------------------------------
# Function name: GetCorrectPath
# Description:   Creates the build environment.
# Arguments:     1.   existing / original path
#                2... pairs of <path, executable>
# Return value:  String - Correct Path
#--------------------------------------------------------
sub GetCorrectPath
{
	sub PathLookup
	{
	    my $cmd = shift;
	    while (@_) {
		my $elem = shift;

		-x "$elem/$cmd" && return $elem;
	    }
	    return '';
	}

	sub SaneGrep
	{
	    # Perl grep is unbelievably strange.
	    my $needle = shift;
	    while (@_) {
		my $haystack = shift;
		if ($needle eq $haystack) {
		    return 1;
		}
	    }
	    return 0;
	}

	sub CleanupPath
	{
	    my @elements = @_;
	    my @cleanName = ();

	    while (@elements) {
		my $elem = shift @elements;
		if (!SaneGrep ($elem, @cleanName)) {
			push @cleanName, $elem;
		}
	    }

	    return @cleanName;
	}

	my $oldPath = shift;
	my @originalPairs = @_;
	my @pairs = @originalPairs;
	my @Path = split /$ps/, $oldPath;

	while (@pairs) {
	    my $path = shift @pairs;
	    my $cmd = shift @pairs;
	    my $to_append = 1;
	    my $elem;

	    if (! -x "$path/$cmd") {
		AddWarning ("Missing executable $path/$cmd\n");
	    }

	    for $elem (@Path) {
		if ($elem eq $path) {
#		    print "Hit duplicate path in path; break\n";
		    $to_append = 0;
		    last;
		}
		if (-f "$elem/$cmd") {
#		    print "Element already in path ...\n";
		    unshift @Path, $path;
		    $to_append = 0;
		    last;
		} else {
#		    print "No file $elem/$cmd\n";
		}
	    }
	    if ($to_append) {
		push @Path, $path;
	    }
	}

	@pairs = @originalPairs;
	while (@pairs) {
	    my $path = shift @pairs;
	    my $cmd = shift @pairs;
	    my $realpath;

	    $realpath = PathLookup ($cmd, @Path);
	    if (!($realpath eq $path)) {
		AddWarning ("Path conflict for executables " .
                            "$path/$cmd against $realpath");
	    }
	}

	return join $ps, CleanupPath (@Path);
}

#------------------------------------------------------------
# Function name: AddWarning
# Description:   Adds any kind of warning for the user.
#                The warning will be shown at the end
#                of this script.
# Arguments:     1. Add the configure warnings or the set_soenv
#                   warning (string).
#                2. Warning (string).
# Return value:  void
#------------------------------------------------------------
sub AddWarning
{  if ( $_[ 0 ] eq "configure" )
   {  open( IN, $warnfile );
      while ( <IN> )
      {  $Warning = $Warning."* - ".$_;
      }
      close( IN );
      # Remove the temporary warning file.
      # unlink ( $warnfile );
   }
   elsif ( $_[ 0 ] eq "set_soenv" )
   {  my ( $arg1 );
      $arg1 = $_[ 1 ];
      chomp( $arg1 );                            # cut off new line
      $Warning = $Warning."* - set_soenv: warning: $arg1 $newline";  # add the warning
   }
}

# vim:set shiftwidth=4 softtabstop=4 expandtab: #
